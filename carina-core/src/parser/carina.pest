// Carina DSL Grammar

// Entry point
file = { SOI ~ statement* ~ EOI }

statement = { provider_block | let_binding | anonymous_resource }

// Anonymous resource: aws.s3.bucket { ... } (top-level)
anonymous_resource = { namespaced_id ~ "{" ~ block_content* ~ "}" }

// Provider block: provider aws { ... }
provider_block = {
    "provider" ~ identifier ~ "{" ~ attribute* ~ "}"
}

// Variable/resource definition: let name = value
let_binding = { "let" ~ identifier ~ "=" ~ expression }

// Block content: either an attribute (key = value) or a nested block (key { ... })
block_content = { attribute | nested_block }

// Attribute: key = value
attribute = { identifier ~ "=" ~ expression }

// Nested block: key { ... } (like Terraform's ingress { ... })
nested_block = { identifier ~ "{" ~ attribute* ~ "}" }

identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// Namespaced identifier: aws.s3.bucket, aws.Region.ap_northeast_1
namespaced_id = @{ identifier ~ ("." ~ identifier)+ }

// Expression
expression = { pipe_expr }

// Pipe operator: value |> func |> func
pipe_expr = { primary ~ ("|>" ~ function_call)* }

// Function call: func(args)
function_call = { identifier ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }

// Primary value
primary = {
    env_var
  | resource_expr
  | list
  | map
  | namespaced_id
  | boolean
  | number
  | string
  | variable_ref
  | "(" ~ expression ~ ")"
}

// List: [item1, item2, ...]
list = { "[" ~ (expression ~ ("," ~ expression)*)? ~ ","? ~ "]" }

// Map: { key = value, ... }
map = { "{" ~ (map_entry ~ ("," ~ map_entry)*)? ~ ","? ~ "}" }

// Map entry: key = value
map_entry = { identifier ~ "=" ~ expression }

// Environment variable: env("VAR_NAME")
env_var = { "env" ~ "(" ~ string ~ ")" }

// Resource expression: aws.s3.bucket { ... }
resource_expr = { namespaced_id ~ "{" ~ block_content* ~ "}" }

// Variable reference (with optional member access: bucket.name)
variable_ref = { identifier ~ ("." ~ identifier)? }

// Literals
boolean = { "true" | "false" }
number = @{ "-"? ~ ASCII_DIGIT+ }
string = ${ "\"" ~ inner_string ~ "\"" }
inner_string = @{ char* }
char = {
    !("\"" | "\\") ~ ANY
  | "\\" ~ ("\"" | "\\" | "n" | "r" | "t")
}

// Whitespace (auto-skip)
WHITESPACE = _{ " " | "\t" | NEWLINE }

// Comment (auto-skip)
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* }
