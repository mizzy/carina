// Carina DSL Grammar

// Entry point
file = { SOI ~ statement* ~ EOI }

statement = { import_stmt | backend_block | provider_block | input_block | output_block | let_binding | module_call | anonymous_resource }

// Input block: input { vpc_id: string, ... }
input_block = {
    "input" ~ "{" ~ input_param* ~ "}"
}

// Input parameter: name: type or name: type = default
input_param = {
    identifier ~ ":" ~ type_expr ~ ("=" ~ expression)?
}

// Output block: output { subnet_ids: list(string), ... }
output_block = {
    "output" ~ "{" ~ output_param* ~ "}"
}

// Output parameter: name: type or name: type = expression
output_param = {
    identifier ~ ":" ~ type_expr ~ ("=" ~ expression)?
}

// Type expression: string, bool, int, list(type), map(type), ref(resource_type)
type_expr = { type_ref | type_generic | type_simple }
type_simple = @{ "string" | "bool" | "int" | "cidr" }
type_generic = { ("list" | "map") ~ "(" ~ type_expr ~ ")" }
type_ref = { "ref" ~ "(" ~ resource_type_path ~ ")" }
resource_type_path = @{ identifier ~ ("." ~ identifier)+ }

// Import statement: import "./path/to/module.crn" as name
import_stmt = {
    "import" ~ string ~ "as" ~ identifier
}

// Backend block: backend s3 { bucket = "...", key = "...", ... }
backend_block = {
    "backend" ~ identifier ~ "{" ~ attribute* ~ "}"
}

// Module call: module_name { key = value, ... }
module_call = {
    identifier ~ "{" ~ module_call_arg* ~ "}"
}

// Module call argument: key = value
module_call_arg = { identifier ~ "=" ~ expression }

// Anonymous resource: aws.s3.bucket { ... } (top-level)
anonymous_resource = { namespaced_id ~ "{" ~ block_content* ~ "}" }

// Provider block: provider aws { ... }
provider_block = {
    "provider" ~ identifier ~ "{" ~ attribute* ~ "}"
}

// Variable/resource definition: let name = value
let_binding = { "let" ~ identifier ~ "=" ~ expression }

// Block content: either an attribute (key = value) or a nested block (key { ... })
block_content = { attribute | nested_block }

// Attribute: key = value
attribute = { identifier ~ "=" ~ expression }

// Nested block: key { ... } (like Terraform's ingress { ... })
nested_block = { identifier ~ "{" ~ attribute* ~ "}" }

identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// Namespaced identifier: aws.s3.bucket, aws.Region.ap_northeast_1
namespaced_id = @{ identifier ~ ("." ~ identifier)+ }

// Expression
expression = { pipe_expr }

// Pipe operator: value |> func |> func
pipe_expr = { primary ~ ("|>" ~ function_call)* }

// Function call: func(args)
function_call = { identifier ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }

// Primary value
primary = {
    env_var
  | resource_expr
  | list
  | map
  | namespaced_id
  | boolean
  | number
  | string
  | variable_ref
  | "(" ~ expression ~ ")"
}

// List: [item1, item2, ...]
list = { "[" ~ (expression ~ ("," ~ expression)*)? ~ ","? ~ "]" }

// Map: { key = value, ... }
map = { "{" ~ (map_entry ~ ("," ~ map_entry)*)? ~ ","? ~ "}" }

// Map entry: key = value
map_entry = { identifier ~ "=" ~ expression }

// Environment variable: env("VAR_NAME")
env_var = { "env" ~ "(" ~ string ~ ")" }

// Resource expression: aws.s3.bucket { ... }
resource_expr = { namespaced_id ~ "{" ~ block_content* ~ "}" }

// Variable reference (with optional member access: bucket.name)
variable_ref = { identifier ~ ("." ~ identifier)? }

// Literals
boolean = { "true" | "false" }
number = @{ "-"? ~ ASCII_DIGIT+ }
string = ${ "\"" ~ inner_string ~ "\"" }
inner_string = @{ char* }
char = {
    !("\"" | "\\") ~ ANY
  | "\\" ~ ("\"" | "\\" | "n" | "r" | "t")
}

// Whitespace (auto-skip)
WHITESPACE = _{ " " | "\t" | NEWLINE }

// Comment (auto-skip)
COMMENT = _{ "#" ~ (!NEWLINE ~ ANY)* }
